// SPDX-License-Identifier: GPL-2.0
/*
 * Copyright (C) 2022 Dennis Kaydalov
 */ 

package org.codeberg.denniskaydalov;

import javax.swing.JPanel;
import java.awt.Graphics;
import java.awt.Point;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.Color;
import java.util.Queue;

public class Grid extends JPanel {
    private Point gridSize;
    private Point position;
    private int cellSize;
    private Cell cells[][];
    private String selection;
    private Cell start;
    private Cell end;
    private Node startNode;
    private Node endNode;
    private Node nodes[];

    private static Grid grid = new Grid();

    private Grid(){};

    public static Grid getInstance() {
        return grid;
    }
    
    public void init(Point gridSize, Point position, int cellSize) {
        this.gridSize = gridSize;
        this.position = position;
        this.cellSize = cellSize;
        selection = "Obstacles";
        cells = new Cell[gridSize.y][gridSize.x];
        setGraph();
        addMouseListener(mouseAdapter);
        constructNodeGraph();
    }


    private void constructNodeGraph() {
        nodes = new Node[gridSize.x * gridSize.x];

        for(int i = 0; i < gridSize.y; ++i) {
            for(int j = 0; j < gridSize.x; ++j) {
                nodes[gridSize.y * i + j] = new Node(gridSize.y * i + j);
            }
        }

        for(int i = 0; i < gridSize.y; ++i) {
            for(int j = 0; j < gridSize.x; ++j) {
                if(j < gridSize.x - 1 && cells[i][j + 1].getColor() != Color.GRAY)
                    nodes[gridSize.y * i + j].addNeighbor(nodes[gridSize.y * i + 1 + j]);
                if(i < gridSize.y - 1 && cells[i + 1][j].getColor() != Color.GRAY)
                    nodes[gridSize.y * i + j].addNeighbor(nodes[gridSize.y * (i + 1) + j]);
            }
        }

        startNode = nodes[(start.getPosition().x-position.x)/cellSize + (start.getPosition().y-position.y)/cellSize * gridSize.y];
        endNode = nodes[(end.getPosition().x-position.x)/cellSize + (end.getPosition().y-position.y)/cellSize * gridSize.y];
    }

    public void setVisited(Queue<Node> queue) {
        for(Node node : queue) {
            //Cell changedCell = cells[node.id % cellSize][node.id / cellSize];
            Cell changedCell = cells[node.id / cellSize][node.id % cellSize];
            if(changedCell != start)
                changedCell.setColor(Color.BLUE);
            update();
        }
        redoVisited();
        previousQueue = queue;
    }

    public Node getStartNode() {
        return startNode;
    }

    public Node getEndNode() {
        return endNode;
    }

    @Override
	public void paintComponent(Graphics g) {
        super.paintComponent( g );

        for(int i = 0; i < gridSize.y; ++i) {
            for(int j = 0; j < gridSize.x; ++j) {
                cells[i][j].draw(g);
            }
        }
    }

    public void setSelection(String selection) {
        this.selection = selection;
    }

    private void update(){
		this.repaint();
	}

    private void redoVisited() {
        for(int i = 0; i < gridSize.y; ++i) {
            for()
        }
    }

    private MouseAdapter mouseAdapter = new MouseAdapter() {
        @Override
        public void mousePressed(MouseEvent e){ 
            switch(selection) {
                case "Obstacles": 
                    //cells[(e.getX()-position.x)/cellSize][(e.getY()-position.y)/cellSize].setColor(Color.GRAY);
                    cells[(e.getY()-position.y)/cellSize][(e.getX()-position.x)/cellSize].setColor(Color.GRAY);
                    constructNodeGraph();
                    break;
                case "Start": 
                    //Cell tempCell = cells[(e.getX()-position.x)/cellSize][(e.getY()-position.y)/cellSize];
                    Cell tempStartCell = cells[(e.getY()-position.y)/cellSize][(e.getX()-position.x)/cellSize];
                    if(tempStartCell.getColor() != Color.RED) {
                        start.setColor(Color.WHITE);
                        start = tempStartCell;
                        start.setColor(Color.GREEN);
                        constructNodeGraph();
                    }
                    break;
                case "End": 
                    Cell tempEndCell = cells[(e.getY()-position.y)/cellSize][(e.getX()-position.x)/cellSize];
                    if(tempEndCell.getColor() != Color.GREEN) {
                        end.setColor(Color.WHITE);
                        end = tempEndCell;
                        end.setColor(Color.RED);
                        constructNodeGraph();
                    }
                    break;
                case "Clear":
                    //cells[(e.getX()-position.x)/cellSize][(e.getY()-position.y)/cellSize].setColor(Color.WHITE);
                    cells[(e.getY()-position.y)/cellSize][(e.getX()-position.x)/cellSize].setColor(Color.WHITE);
                    break;
            }
            update();
        }
    };

    private void setGraph() {
        for(int i = 0; i < gridSize.y; ++i) {
            for(int j = 0; j < gridSize.x; ++j) {
                //cells[j][i] = new Cell(new Point(position.x + cellSize * j, position.y + cellSize * i), cellSize);
                cells[i][j] = new Cell(new Point(position.x + cellSize * j, position.y + cellSize * i), cellSize);
            }
        }
        start = cells[0][0];
        start.setColor(Color.GREEN);
        end = cells[gridSize.y - 1][gridSize.x - 1];
        end.setColor(Color.RED);
    }
}
